global_options â† â€¢args

âŸ¨BM32, _DoWhile_âŸ© â† â€¢Import "util.bqn"
ffi â† global_options â€¢Import "pcre2_ffi.bqn"
âŸ¨pcre2_optionsâŸ© â† â€¢Import "pcre2_options.bqn"
âŸ¨errorâŸ© â† â€¢Import "pcre2_codes.bqn"
âŸ¨U64ToU32, U32ToU64, U64VecRead, PtrVecReadâŸ© â† â€¢Import "bqn_ffi.bqn"
âŸ¨ReadStrPtr, VerifyStr, DirectPtrâŸ© â† global_options â€¢Import "strings.bqn"

null â† 8â¥Š0

FnErr â† {!ğ•©âˆ¾âŠ¢}

CEFree â‡ {ğ•Š reâ€¿match_dataâ€¿match_context:
  ffi.Match_Context_Free match_context
  ffi.Match_Data_Free match_data
  ffi.Code_Free re
}

ErrorMsg â† {ğ•Š errcode:
  e â† FnErr "pcre2_get_error_message "
  râ€¿message â† ffi.Get_Error_Message âŸ¨errcode, 256â¥Š@, 256âŸ©
  {
    r â‰¡ error.nomemory? E "buffer too small to contain error message";
    r â‰¡ error.baddata? E "unrecognized error code";
    r â‰¥ 0? râ†‘message;
    E "error"
  }
}

U32 â† (2â‹†32)|âŠ¢

CreateMContext â† {ğ•Š options:
  e â† FnErr "pcre2_match_context_create "
  dâ€¿mâ€¿hâ€¿o â† co â† options â€¢ns.GetÂ¨ "depthlimit"â€¿"matchlimit"â€¿"heaplimit"â€¿"offsetlimit"
  { âˆ§Â´@=co? null;
    c â† ffi.Match_Context_Create null
    EâŸ(câ‰¡null) "could not obtain memory for match context"
    c ffi.Set_Depth_LimitâŸœU32âŸ(@âŠ¸â‰¢) d
    c ffi.Set_Match_LimitâŸœU32âŸ(@âŠ¸â‰¢) m
    c ffi.Set_Heap_Limit âŸœU32âŸ(@âŠ¸â‰¢) h
    c ffi.Set_Offset_LimitâŸ(@âŠ¸â‰¢)    o
    c
  }
}

CreateMData â† {ğ•Š re:
  e â† FnErr "pcre2_match_data_create_from_pattern "
  match_data â† ffi.Match_Data_Create_From_Pattern âŸ¨re, nullâŸ©
  EâŸ(match_dataâ‰¡null) "could not obtain memory for match data block"
  match_data
}

Compile â‡ {ğ•Š patternâ€¿options: # TODO: show error position on failure
  e â† FnErr "pcre2_compile "
  pattern VerifyStrâ†©
  ccontext â† null # TODO compilecontext to allow setting LF character
  reâ€¿âŸ¨errâŸ©â€¿erroffset â† ffi.Compile âŸ¨ DirectPtr pattern, â‰ pattern,
                                     BM32 options.comp,
                                     âŸ¨0âŸ©, 0â€¿0, ccontext âŸ©
  Eâˆ˜ErrorMsgâŸ(reâ‰¡null) err

  match_data â† CreateMData re
  match_context â† CreateMContext options

  reâ€¿match_dataâ€¿match_context
}

CompileJIT â‡ {ğ•Š reâ€¿options:
  e â† FnErr "pcre2_jit_compile "
  err â† ffi.JIT_Compile âŸ¨re, BM32 optionsâŸ©
  {
    err â‰¡ error.nomemory? E "unable to allocate executable memory";
    err < 0? E Errormsg err;
    err â‰¡ 0? re;
    E "unreachable"
  }
}

_OnMatch_ â† {default _ğ•£_ Fn âŸ¨reâ€¿match_dataâ€¿match_context, pinputâ€¿ninputâ€¿offset, optionmaskâŸ©:
  e â† FnErr "pcre2_match "
  rc â† ffi.Match âŸ¨ re, pinput, ninput, offset,
                   optionmask,
                   match_data, match_context âŸ©
  {
    rc â‰¡ error.nomatch? default;
    rc â‰¡ 0? E "ovector size error";
    rc < 0? E ErrorMsg rc;
    rc Fn match_data
  }
}

GetSubstrings â† {n ğ•Š match_data:
  e â† FnErr  "pcre2_substring_list_get "
  errâ€¿plistsâ€¿plengths â† ffi.Substring_List_Get âŸ¨match_data, null, nullâŸ©
  {
    err â‰¢ 0? E ErrorMsg err;
    lengths â† n U64VecRead plengths
    pstrs â† n PtrVecRead plists
    res â† lengths ReadStrPtrÂ¨ pstrs
    ffi.Substring_List_Free plists
    â€¢FromUtf8âš‡1âŸ(global_options.modeâ‰¡3) âŠ‘âŸ(nâ‰¡1) res
  }
}

GetOVecs â† {n ğ•Š match_data:
  <Ë˜âˆ˜â€¿2â¥Š (2Ã—n) U64VecRead ffi.Get_OVector_Pointer match_data
}

ProcInput â† {ğ•Š âŸ¨ce, input, optionsâŸ©:
  input VerifyStrâ†©
  âŸ¨ce, âŸ¨DirectPtr input, â‰ input, 0âŸ©, BM32 optionsâŸ©
}

Test   â‡ 0 _OnMatch_ 1              ProcInput
Match  â‡ âŸ¨âŸ©_OnMatch_ GetSubstrings  ProcInput
IMatch â‡ âŸ¨âŸ©_OnMatch_ GetOVecs       ProcInput

MatchAll â‡ {ğ•Š âŸ¨ce, pinputâ€¿lenâ€¿offset, optionmaskâŸ©:
  iter â† global_options.overlapping âŠ‘ âŸ¨1âŠ¸âŠ‘, 1+âŠ‘âŸ© # potential bug from inc 1+âŠ‘ in utf8 mode?
  NextOffset â† {offsetâ†© Iter âŠ‘ 1 GetOVecs ğ•©}
  Iâ†{ğ•Š: ceâ€¿âŸ¨pinput, len, offsetâŸ©â€¿optionmask}

  results â† âŸ¨âŸ© â‹„ Append â† {resultsâˆ¾â†©<ğ•©}
  âŸ¨âŸ©_OnMatch_(GetSubstringsâŠ£NextOffset)âˆ˜I _DoWhile_ {âŸ¨âŸ©:0; 1âŠ£Appendğ•©} @
  results
}âˆ˜ProcInput

Substitute â† { buflen ğ•Š âŸ¨reâ€¿match_dataâ€¿match_context, pattern, pinputâ€¿ninputâ€¿offset, optionmaskâŸ©:
  e â† FnErr "pcre2_substitute "
  rcâ€¿outâ€¿nout â† ffi.Substitute âŸ¨ re, pinput, ninput, offset,
                                 optionmask, match_data, match_context,
                                 pattern, â‰ pattern,
                                 @â¥ŠËœU32ToU64 buflen, buflen âŸ©
  {
    rc â‰¡ error.nomemory? nout Substitute ğ•©;
    rc < 0? E ErrorMsg rc;
    â€¢FromUtf8âš‡1âŸ(global_options.modeâ‰¡3) (U32ToU64 nout) â†‘ out
  }ğ•©
}

SetOverflow â† pcre2_options.substitute_overflow_lengthâŠ¸âˆ¨âŒ¾(2âŠ¸âŠ‘)
SetGlobal   â† pcre2_options.         substitute_globalâŠ¸âˆ¨âŒ¾(2âŠ¸âŠ‘)

Replace â‡ { pattern ğ•Š âŸ¨ce, input, option_maskâŸ©:
  bufsize â† U64ToU32 global_options.InitSubBuf 1âŠ‘input
  bufsize Substitute âŸ¨ce, VerifyStr pattern, input, option_maskâŸ©
}âŸœ(ProcInput SetOverflow)

ReplaceAll â‡ ReplaceâŸœSetGlobal
